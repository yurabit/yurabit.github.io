<!DOCTYPE html>
<html lang="en-us"><title>
    Protobuf2语言指南（翻译） | 
    
    王源豫个人博客</title>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

<meta name="description" 
      content="注：内容翻译自官方文档，仅作个人学习使用。原文
 语言指南   定义一个消息类型
  Scalar值类型
  可选值与默认值
  枚举
  使用其他消息类型
  嵌套类型
  更新消息类型
  扩展
  Oneof
  Maps
  包
  定义服务
  选项
  生成类
 这个指南为我们描述了利用Protocal Buffer语言来结构化Protocal Buffer数据的方法，包括了.proto文件的语法和怎样从.proto文件中生成数据访问类。其包含了proto2版本的内容：如果想了解有关与proto3的语法，请参看Proto3 Language Guide。
   定义一个消息类型(Defining a message type)  首先，让我们来看一个非常简单的例子。我们说当你想要定义一个Search Request的消息格式，其中每一个Search Request都有一个字符串类型的Query，一个你感兴趣内容的特定页码，还有每一页需要多少结果。下面的.proto文件就是来定义上述的消息类型。
 message SearchRequest {	required string query = 1;	optional int32 page_number = 2;	optional int32 result_per_page = 3;} 消息类型的SearchRequest中定义了上述所要求的三个字段（名称/值 的对），每一份数据都会在字段中有相应的数据，每一个字段都有一个名称和一个类型。
                ">

<link rel="canonical" href="/post/protobuf2languageguide/" />

<link rel="icon" type="image/png" href="/image/favicon.ico">

<link rel="stylesheet" href="/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/bulma.min.css">

<meta property="og:title" content="Protobuf2语言指南（翻译）" />
<meta property="og:description" content="注：内容翻译自官方文档，仅作个人学习使用。原文
 语言指南   定义一个消息类型
  Scalar值类型
  可选值与默认值
  枚举
  使用其他消息类型
  嵌套类型
  更新消息类型
  扩展
  Oneof
  Maps
  包
  定义服务
  选项
  生成类
 这个指南为我们描述了利用Protocal Buffer语言来结构化Protocal Buffer数据的方法，包括了.proto文件的语法和怎样从.proto文件中生成数据访问类。其包含了proto2版本的内容：如果想了解有关与proto3的语法，请参看Proto3 Language Guide。
   定义一个消息类型(Defining a message type)  首先，让我们来看一个非常简单的例子。我们说当你想要定义一个Search Request的消息格式，其中每一个Search Request都有一个字符串类型的Query，一个你感兴趣内容的特定页码，还有每一页需要多少结果。下面的.proto文件就是来定义上述的消息类型。
 message SearchRequest {	required string query = 1;	optional int32 page_number = 2;	optional int32 result_per_page = 3;} 消息类型的SearchRequest中定义了上述所要求的三个字段（名称/值 的对），每一份数据都会在字段中有相应的数据，每一个字段都有一个名称和一个类型。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/protobuf2languageguide/" />
<meta property="article:published_time" content="2020-06-17T22:52:20+08:00" />
<meta property="article:modified_time" content="2020-06-17T22:52:20+08:00" /><meta property="og:site_name" content="王源豫个人博客" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Protobuf2语言指南（翻译）"/>
<meta name="twitter:description" content="注：内容翻译自官方文档，仅作个人学习使用。原文
 语言指南   定义一个消息类型
  Scalar值类型
  可选值与默认值
  枚举
  使用其他消息类型
  嵌套类型
  更新消息类型
  扩展
  Oneof
  Maps
  包
  定义服务
  选项
  生成类
 这个指南为我们描述了利用Protocal Buffer语言来结构化Protocal Buffer数据的方法，包括了.proto文件的语法和怎样从.proto文件中生成数据访问类。其包含了proto2版本的内容：如果想了解有关与proto3的语法，请参看Proto3 Language Guide。
   定义一个消息类型(Defining a message type)  首先，让我们来看一个非常简单的例子。我们说当你想要定义一个Search Request的消息格式，其中每一个Search Request都有一个字符串类型的Query，一个你感兴趣内容的特定页码，还有每一页需要多少结果。下面的.proto文件就是来定义上述的消息类型。
 message SearchRequest {	required string query = 1;	optional int32 page_number = 2;	optional int32 result_per_page = 3;} 消息类型的SearchRequest中定义了上述所要求的三个字段（名称/值 的对），每一份数据都会在字段中有相应的数据，每一个字段都有一个名称和一个类型。"/>



    


<script src=/js/ramium.js></script>
<link rel="stylesheet" href=/css/ramium.css>





<body><nav class="navbar is-dark" role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a class="navbar-item" href=/>
      
      <strong>王源豫个人博客 </strong>
      
    </a>

    <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false"
      data-target="navbarBasicExample">
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
    </a>
  </div>

  <div id="navbarBasicExample" class="navbar-menu">
    <div class="navbar-start">
      
      
      <a class="navbar-item" href="/about">AboutMe</a>
      
      
      
      <a class="navbar-item" href="/post">文章</a>
      
      
      
      <a class="navbar-item" href="/catalogue">目录</a>
      
      
    </div>

    <div class="navbar-end">
      

      
    </div>
  </div>
</nav><div class="columns is-centered">
        <div id="page-body" class="column is-7">

<div class="content blog">
    <h1 class="title">Protobuf2语言指南（翻译）</h1>

    <div id="infobar" class="level is-mobile">
        <div class="level-left">
            

            <div class="level-item">
                <p class="subtitle info">
                    54 mins read
                </p>
            </div>
        </div>
        <div class="level-right is-hidden-touch">
            <div class="tags">
                
                <a class="tag is-dark is-rounded" href="/tags/rpc">RPC</a>
                
                <a class="tag is-dark is-rounded" href="/tags/protobuf">Protobuf</a>
                
            </div>
        </div>
    </div>

    <div class="tags is-hidden-desktop">
        
        <a class="tag is-dark is-rounded" href="/tags/rpc">R p c</a>
        
        <a class="tag is-dark is-rounded" href="/tags/protobuf">Protobuf</a>
        
    </div>

    <div class="blog-text">
        

        <blockquote>
<p>注：内容翻译自官方文档，仅作个人学习使用。<a href="https://developers.google.com/protocol-buffers/docs/proto">原文</a></p>
</blockquote>
<h3 id="语言指南">语言指南</h3>
<ul>
<li>
<p><a href="#message">定义一个消息类型</a></p>
</li>
<li>
<p><a href="#scalar">Scalar值类型</a></p>
</li>
<li>
<p><a href="#optional">可选值与默认值</a></p>
</li>
<li>
<p><a href="#enumerations">枚举</a></p>
</li>
<li>
<p><a href="#using">使用其他消息类型</a></p>
</li>
<li>
<p><a href="#nested">嵌套类型</a></p>
</li>
<li>
<p><a href="#updating">更新消息类型</a></p>
</li>
<li>
<p><a href="#extensions">扩展</a></p>
</li>
<li>
<p><a href="#oneof">Oneof</a></p>
</li>
<li>
<p><a href="#maps">Maps</a></p>
</li>
<li>
<p><a href="#packages">包</a></p>
</li>
<li>
<p><a href="#services">定义服务</a></p>
</li>
<li>
<p><a href="#options">选项</a></p>
</li>
<li>
<p><a href="#generating">生成类</a></p>
<blockquote>
<p>这个指南为我们描述了利用Protocal Buffer语言来结构化Protocal Buffer数据的方法，包括了<code>.proto</code>文件的语法和怎样从<code>.proto</code>文件中生成数据访问类。其包含了<strong>proto2</strong>版本的内容：如果想了解有关与<strong>proto3</strong>的语法，请参看<a href="https://developers.google.com/protocol-buffers/docs/proto3">Proto3 Language Guide</a>。</p>
</blockquote>
</li>
</ul>
<h3 id="span-idmessage定义一个消息类型defining-a-message-typespan"><span id="message">定义一个消息类型(Defining a message type)</span></h3>
<blockquote>
<p>首先，让我们来看一个非常简单的例子。我们说当你想要定义一个<code>Search Request</code>的消息格式，其中每一个<code>Search Request</code>都有一个字符串类型的<code>Query</code>，一个你感兴趣内容的特定页码，还有每一页需要多少结果。下面的<code>.proto</code>文件就是来定义上述的消息类型。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">SearchRequest</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">required</span> <span style="color:#66d9ef">string</span> query <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">optional</span> <span style="color:#66d9ef">int32</span> page_number <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">optional</span> <span style="color:#66d9ef">int32</span> result_per_page <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p>消息类型的<code>SearchRequest</code>中定义了上述所要求的三个字段（名称/值 的对），每一份数据都会在字段中有相应的数据，每一个字段都有一个名称和一个类型。</p>
</blockquote>
<h4 id="指定字段的类型">指定字段的类型</h4>
<blockquote>
<p>在上述的例子中，所有的字段都是Scalar值类型：两个整型（<code>page_number</code>和<code>result_per_page</code>）和一个字符串类型（<code>query</code>）。然而，你也可以指定复合类型，包括枚举（Enumberations）类型和其他消息（Message）类型。</p>
</blockquote>
<h4 id="为字段设置数值">为字段设置数值</h4>
<blockquote>
<p>正如上面所看到的那样，在消息体中定义的每个字段都有一个<strong>唯一的数字</strong>。这些数字是用来作为每一个字段的二进制消息格式的标识符，一旦消息类型已经进入使用阶段则这个唯一的数字将不可改变。字段的数字标识在1-15之间的时候会使用1个字节来编码，包括了字段的数值和字段的种类。字段数字标识在16-2047的会使用两个字节。所以你应该把1-15号数字标识为那些会经常出现的消息子元素保留。记得为将来可能被加入进来的经常出现的元素留下足够的空间。</p>
<p>你可以指定的最小的数字标识是1，最大的数字标识是$2^{29}-1$,或者536,870,911。数字19000-19999（<code>FieldDescriptor::kFirstReservedNumber</code>-<code>FieldDescriptor::kLastReservedNumber</code>)、他们被保留用来作为Protocal Buffer的实现-protocal buffer的编译器会报错如果你在你的<code>.proto</code>文件里使用了这些保留的数字，同样你也不能使用之前保留下来的数字。</p>
</blockquote>
<h4 id="指定字段的规则">指定字段的规则</h4>
<blockquote>
<p>你可以指定你的消息类型的字段为以下三种类型：</p>
<ul>
<li><code>required</code>:一个符合语法规定的在消息体中有且仅有一个的字段</li>
<li><code>optional</code>:在消息体中有0或1个（不能超过1）</li>
<li><code>repeated</code>:这一类型的字段可以有任意多个（包括0），字段内部的顺序会被保留下来。</li>
</ul>
<p>由于一些历史原因，<code>repeated</code>字段的数字数值类型不能够有效的被编码。新的代码要使用一个特殊的选项<code>[packed=true]</code>来获得一个更高效的编码，如下：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">repeated</span> <span style="color:#66d9ef">int32</span> samples <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span> [packerd<span style="color:#f92672">=</span><span style="color:#66d9ef">true</span>]<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p><code>required</code>所标记的字段将会永远不变，所以当我们以<code>required</code>来 定义字段时要格外小心。如果当某一个时间你想要停止写入并且发送一个<code>required</code>字段的话，我们想要把他们变成optional将会存在很大的问题：旧版本的读者会认为这个消息缺少了这个字段是不完整的，并且因此会在无意间拒绝或者丢弃这些消息。你应该考虑为缓冲区编写特定于应用程序的自定义验证例程。一些谷歌的开发人员认为使用<code>required</code>利少于弊，他们更倾向于只使用<code>optional</code>和<code>repeated</code>。但这种观点并不是普遍的。</p>
</blockquote>
<h4 id="添加更多消息类型">添加更多消息类型</h4>
<blockquote>
<p>在同一个<code>.proto</code>文件里可以定义多个消息类型。如果你准备设计多个相关联的消息这将是非常有用的，比如，如果你想要定义定义一个回复消息格式<code>SearchResponse</code>消息类型，你可以在你的<code>.proto</code>文件中加入：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">SearchRequest</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">required</span> <span style="color:#66d9ef">string</span> query <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">optional</span> <span style="color:#66d9ef">int32</span> page_number <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">optional</span> <span style="color:#66d9ef">int32</span> result_per_page <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">SearchResponse</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#f92672">.</span><span style="color:#f92672">.</span><span style="color:#f92672">.</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p><strong>但是合并信息会导致信息的膨胀</strong>，在一个<code>.proto</code>文件中如果定义了很多的消息（如message，enum，service等）。当单个文件中 定义大量具有不同依赖关系的消息时，也可能会导致消息膨胀。所以我们更建议你在每一个 <code>.proto</code>文件中写尽可能少的消息。</p>
</blockquote>
<h4 id="添加注释">添加注释</h4>
<blockquote>
<p>如果想要在<code>.proto</code>文件中添加注释，可以使用C/C++风格的注释<code>//</code>或<code>/* ... */</code></p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#75715e">/* SearchRequest represents a search query, with pagination options to
</span><span style="color:#75715e"> * indicate which results to include in the response */</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">SearchRequest</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">required</span> <span style="color:#66d9ef">string</span><span style="color:#f92672">.</span> query <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">optional</span> <span style="color:#66d9ef">int32</span> page_number <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">// Which page number do we want?
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">optional</span> <span style="color:#66d9ef">int32</span> result_per_page <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>; <span style="color:#75715e">// Number of results to return per page.
</span><span style="color:#75715e"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><h4 id="保留字段">保留字段</h4>
<blockquote>
<p>如果你将一个已有消息类型的一整个字段都移除，或者是把他注释掉，未来的用户可能会重用这条消息或者是定义自己的字段。当这些用户加载了之前的版本的<code>.proto</code>文件时，将会产生非常严重的问题（数据冲突，隐私问题等等）。我们提出一种可以防止这种情况发生的方法就是指定保留这些字段的数字标识（和/或名称，这也可能导致Json序列化的问题）。如果将来有任何用户尝试使用这些标识符，则Protocal Buffer的编译器将会报错。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">Foo</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	reserved <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">9</span> <span style="color:#66d9ef">to</span> <span style="color:#ae81ff">11</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	reserved <span style="color:#e6db74">&#34;foo&#34;</span>, <span style="color:#e6db74">&#34;bar&#34;</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p>注意：你不可以将标识符和名字放在同一个<code>reserved</code>关键字中。</p>
</blockquote>
<h4 id="从你的proto文件会生成什么">从你的<code>.proto</code>文件会生成什么</h4>
<blockquote>
<p>当你对<code>.proto</code>文件运行Protocal Buffer编译器，编译器将会生成生成你指定语言的代码相应数据类型的消息类，包括所有字段的的<code>getting</code>、<code>setting</code>方法、把你的消息序列化到一个输出流，并把你的输入流中的数据转换成相应语言的消息。</p>
<ul>
<li>对于<strong>C++</strong>， 编译器会从每个<code>.proto</code>文件中产生<code>.h</code>和<code>.cc</code>文件，每一个<code>.proto</code>文件中描述的消息，都会生成一个对应的类。</li>
<li>对于<strong>Java</strong>语言，编译器会产生一个<code>.java</code>文件，这个文件会为每个消息创造一个类，同时也会生成一个特别的<code>Builder</code>类来制造每一个消息实例。</li>
<li><strong>Python</strong>会有一些不一样-Python的编译器会根据每一个<code>.proto</code>文件中的类产生一个带有静态描述符的模块。这些会在接下来根据元类在运行时生成Python所必须的数据。</li>
<li>对于<strong>Go</strong>语言，编译器会产生一个<code>.pb.go</code>的文件，并且每一个消息都会对应一个<code>type</code>。</li>
</ul>
<p>等</p>
</blockquote>
<h3 id="span-idscalarscalar值类型scalar-value-typesspan"><span id="scalar">Scalar值类型(Scalar value types)</span></h3>
<blockquote>
<p>一个Scalar值类型的消息字段可以有以下几种类型组成：下面的表格显示了<code>.proto</code>文件中指定的类型，并且也显示了其他几种主流语言对应的类型。</p>
</blockquote>
<table>
<thead>
<tr>
<th>proto Type</th>
<th>Notes</th>
<th>C++ Type</th>
<th>Java Type</th>
<th>Python Type$^{2}$</th>
<th>Go Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>double</td>
<td></td>
<td>double</td>
<td>double</td>
<td>float</td>
<td>*float64</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>float</td>
<td>float</td>
<td>float</td>
<td>*float64</td>
</tr>
<tr>
<td>int32</td>
<td>使用的变长编码。对负数的编码效率很低：如果你的字段可能存在负数，那么请使用<code>sint32</code>代替。</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>*int32</td>
</tr>
<tr>
<td>int64</td>
<td>使用的变长编码。对负数的编码效率很低：如果你的字段可能存在负数，那么请使用<code>sint64</code>代替。</td>
<td>int64</td>
<td>long</td>
<td>int/long$^{[3]}$</td>
<td>*int64</td>
</tr>
<tr>
<td>uint32</td>
<td>使用的变长编码。</td>
<td>uint32</td>
<td>int$^{[1]}$</td>
<td>int/long$^{[3]}$</td>
<td>*uint32</td>
</tr>
<tr>
<td>uint64</td>
<td>使用的变长编码。</td>
<td>uint64</td>
<td>long$^{[1]}$</td>
<td>int/long$^{[3]}$</td>
<td>*uint64</td>
</tr>
<tr>
<td>sint32</td>
<td>使用变长编码。有符号的int值。将会比<code>int32</code>具有更高效的对负数编码能力。</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>*int32</td>
</tr>
<tr>
<td>sint64</td>
<td>使用变长编码。有符号的int值。将会比<code>int64</code>具有更高效的对负数编码能力。</td>
<td>int64</td>
<td>long</td>
<td>int/long$^{[3]}$</td>
<td>*int64</td>
</tr>
<tr>
<td>fixed32</td>
<td>永远是4字节，当这些值总是大于$2^{28}$时，比<code>uint32</code>更加高效。</td>
<td>uint32</td>
<td>int$^{[1]}$</td>
<td>int/long$^{[3]}$</td>
<td>*uint32</td>
</tr>
<tr>
<td>fixed64</td>
<td>永远是8字节，当这些值总是大于$2^{56}$时，比<code>uint64</code>更加高效。</td>
<td>uint64</td>
<td>long$^{[1]}$</td>
<td>int/long$^{[3]}$</td>
<td>*uint64</td>
</tr>
<tr>
<td>sfixed32</td>
<td>永远是4字节。</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>*int32</td>
</tr>
<tr>
<td>sfixed64</td>
<td>永远是8字节。</td>
<td>int64</td>
<td>long</td>
<td>int</td>
<td>*int64</td>
</tr>
<tr>
<td>bool</td>
<td></td>
<td>bool</td>
<td>boolean</td>
<td>bool</td>
<td>*bool</td>
</tr>
<tr>
<td>string</td>
<td>字符串，必须 包含UTF-8编码或者7位的ASCII码文本。</td>
<td>strinng</td>
<td>string</td>
<td>unicode(Python 2) or str(Python 3)</td>
<td>*string</td>
</tr>
<tr>
<td>bytes</td>
<td>可以包含任意的字节序列</td>
<td>string</td>
<td>ByteString</td>
<td>bytes</td>
<td>[]bytes</td>
</tr>
</tbody>
</table>
<blockquote>
<p>你可以在<a href="https://developers.google.cn/protocol-buffers/docs/encoding">Protocal Buffer Encoding</a>中学习到更多关于怎样将这些类型的编码并序列化的</p>
<p>$^{[1]}$在Java中，无符号的32位和64位整型都会用他们的有符号类型的对应数字表示，其中最高位存储在符号位中。</p>
<p>$^{[2]}$无论何时，为字段设置值将会执行类型检查，来确保它是有效的。</p>
<p>$^{[3]}$64位或者无符号的32位整数在解码时都会表示成long，但如果在设置字段的时候给出了int，则可以表示为int。无论何时，值必须适合在设置时所给出的类型，参考$^{[2]}$。</p>
</blockquote>
<h3 id="span-idoptional可选值与默认值optional-and-default-valuesspan"><span id="optional">可选值与默认值(Optional and default values)</span></h3>
<blockquote>
<p>正如上面所提到的，所有的消息体中描述的元素可以被<code>optional</code>标签所描述。一个具有较好格式的消息可能包含也可能不包含有<code>optional</code>的元素。在解析消息的时候，如果他不包含可选的元素，则解析对象中的对应字段会被设置为该字段的默认值。默认值可以指定为消息描述的一部分。例如，加入你想为<code>SearchRequest</code>的<code>result_per_page</code>值提供默认值10:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">optional</span> <span style="color:#66d9ef">int32</span> result_per_page <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> [<span style="color:#66d9ef">default</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>];<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p>如果没有为一个<code>optional</code>的元素指定一个默认值，那么该值对应的类型的默认值将会被赋予给当前元素：对于字符串来说，默认的值就是一个空的字符串。对于字节来说，默认值将会是一个空的字节字符串。对于布尔类型，默认值为<code>false</code>。对于数值类型，默认值为0。对于枚举类型，默认值将会是列表中定义的第一个值。这将意味着当我们设置枚举类型的第一个值的时候要格外的注意。</p>
</blockquote>
<h3 id="span-idenumerations枚举enumerationsspan"><span id="enumerations">枚举(Enumerations)</span></h3>
<blockquote>
<p>当你定义一个消息类型的时候，你可能会想要让你的其中一个字段只有一个预定义好的值。比如，我们说你想要为每个<code>SerchRequest</code>加一个<code>corpus</code>字段，其中这个<code>corpus</code>字段可以是<code>UNIVERSAL</code>,<code>WEB</code>,<code>IMAGES</code>,<code>LOCAL</code>,<code>NEWS</code>,<code>PRODUCTS</code>或者是<code>VIDEO</code>。你可以添加一个<code>enum</code>类型的消息来简单的做到这样的事情。一个<code>enum</code>关键字修饰的类型将仅含有一个指定集合中的常量来作为他的值（如果你试图提供不同的值，解析器将会认为他是一个未知字段）。下面的例子我们就是在<code>SearchRequest</code>中加入了一个名为<code>Corpus</code>的枚举类型。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">SearchRequest</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">required</span> <span style="color:#66d9ef">string</span> query <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">optional</span> <span style="color:#66d9ef">int32</span> page_number <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">optional</span> <span style="color:#66d9ef">int32</span> result_per_page <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> [<span style="color:#66d9ef">default</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>]<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">enum</span> Corpus {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		UNIVERSAL <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		WEB <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		IMAGES <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		LOCAL <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		NEWS <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		PRODUCTS <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		VIDEO <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	}<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">optional</span> Corpus corpus <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span> [<span style="color:#66d9ef">default</span> <span style="color:#f92672">=</span> UNIVERSAL]<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p>可以通过将相同的值赋值给不同的枚举常量来定义别名。可以通过将<code>allow_alias</code>选项设置为<code>true</code>来做到这点，否则当发现一个别名的时候Protocal Buffer的编译器将会产生一个错误消息。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">enum</span> EnumAllowingAlias {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">option</span> allow_alias <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	UNKNOWN <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	STARTED <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	RUNNING <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">enum</span> EnumNotAllowingAlias {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	UNKNOWN <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	STARTED <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#75715e">// RUNNING = 1; // 这行注释如果取消掉的话将会在谷歌服务器内部引发一个错误，并会向外部发出一个警告消息。
</span><span style="color:#75715e"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p>枚举的常量值必须在32位整型范围内。因为<code>enum</code>类型的值在网络上使用的是变长编码，所以负数的编码将会降低效率，因此不建议使用负数作为enum值。你可以在消息定义的内部定义枚举（向上面的例子那样），也可以在消息定义的外部定义枚举：这些枚举可以在<code>.proto</code>文件中的任何消息定义中重用。还可以使用<code>_MessageType_._EnumType_</code>使得在一个消息中声明的枚举类型作为另一个消息中的字段类型。</p>
<p>当在一个使用了枚举类型的<code>.proto</code>文件中运行protocal buffer编译器的时候，生成的代码会为Java和C++生成对应的<code>enum</code>类型，或者是为Python产生一个特殊的<code>EnumDescriptor</code>类，用于在运行时生成的类中创建一组具有整数值的符号常量。</p>
</blockquote>
<h4 id="保留值">保留值</h4>
<blockquote>
<p>如果你准备将整个枚举入口删除或者注释掉枚举类型来更新枚举类型，未来的用户可以在对该类型进行更新时重用该数值。如果他们以后加载相同的<code>.proto</code>文件的旧版本，这将导致非常严重的问题，包括数据破坏、隐私问题等等。确保不会发证这种情况的一种方法是指定保留已删除条目的数值（和/或名称，这也会导致JSON序列化问题）。如果将来有任何用户试图使用这些标识符，Protocal Buffer编译器将会报错，还可以使用<code>max</code>关键字来制定保留的数值范围可以达到的最大值。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">enum</span> Foo {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	reserved <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">15</span>,  <span style="color:#ae81ff">9</span> <span style="color:#66d9ef">to</span> <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">40</span> <span style="color:#66d9ef">to</span> <span style="color:#66d9ef">max</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	reserved. <span style="color:#e6db74">&#34;FOO&#34;</span>, <span style="color:#e6db74">&#34;BAR&#34;</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p>注意：你不可以将标识符和名字放在同一个<code>reserved</code>关键字中。</p>
</blockquote>
<h3 id="span-idusing使用其他消息类型using-other-typesspan"><span id="using">使用其他消息类型(Using other types)</span></h3>
<blockquote>
<p>你也可以使用其他的消息类型来作为当前消息的字段。举个例子，如果你想要在<code>SearchResponse</code>消息中包含一个<code>Result</code>消息，为了做到这一点，你可以先定义一个<code>Result</code>消息类型，然后在同一个<code>.proto</code>文件中在<code>SearchResponse</code>消息中指定<code>Result</code>字段。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">SearchReponse</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">repeated</span> Result result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">Result</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">required</span> <span style="color:#66d9ef">string</span> url <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">optional</span> <span style="color:#66d9ef">string</span> title <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">repeated</span> <span style="color:#66d9ef">string</span> snippets <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><h4 id="导入定义">导入定义</h4>
<blockquote>
<p>在上面的例子中，<code>Result</code>消息类型是定义在<code>SearchResponse</code>消息所在的同一个<code>.proto</code>文件中，那么如果想要使用另一个<code>.proto</code>文件中的定义好的类型该怎么办呢？</p>
<p>你可以通过<em>import</em>这些消息类型所在的<code>.proto</code>文件来使用它们。为此，你需要在文件的头部添加一条 <code>import</code>声明：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#34;myproject/other_protos.proto&#34;</span>;<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p>在默认情况下，你只可以使用直接导入的<code>.proto</code>文件中的定义。然而，有时候你可能会需要将一个<code>.proto</code>文件移动到一个新的位置。现在，你可以放置一个假的<code>.proto</code>文件，使用<code>import public</code>概念将所有导入转发到新的位置，而不用直接移动<code>.proto</code>文件并在单个的更改中更新所有的调用处的声明。任何使用了<code>import public</code>语句的原型的人都可以传递地依赖倒入公共依赖项。比如：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#75715e">// new.proto
</span><span style="color:#75715e"></span><span style="color:#75715e">// 所有的定义都被移到了这里
</span></code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#75715e">// old.proto
</span><span style="color:#75715e"></span><span style="color:#75715e">// 这是所有客户端本身引用的.proto文件
</span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> public <span style="color:#e6db74">&#34;new.proto&#34;</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#34;other.proto&#34;</span>;<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#75715e">// 客户端的.proto
</span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#34;old.proto&#34;</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e">// 你可以用old.proto和new.proto中定义的文件
</span></code></pre></div><blockquote>
<p>Protocol Buffer的编译器去寻找导入的文件的时候可以使用<code>-I/--proto_path</code>标志来搜索。如果没有给出一个标志，编译器将会在编译命令调用的位置开始搜索。通常，会将<code>--proto_path</code>标志设置为项目的根目录，并对所有的导入使用完全的限定名。</p>
</blockquote>
<h4 id="使用proto3的消息类型">使用proto3的消息类型</h4>
<blockquote>
<p>支持导入proto3的消息类型并且在proto2消息类型中使用，反之亦然。然而proto2中的enum类型却不能在proto3的语法中使用。</p>
</blockquote>
<h3 id="span-idnested嵌套类型nested-typesspan"><span id="nested">嵌套类型(Nested types)</span></h3>
<blockquote>
<p>你可以在一个消息内部定义并使用一个消息，像下面的例子那样：在这里<code>Result</code>消息类型被定义在了<code>SearchResponse</code>消息中：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">SearchResponse</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">message</span> <span style="color:#a6e22e">Result</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		<span style="color:#66d9ef">required</span> <span style="color:#66d9ef">string</span> url <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		<span style="color:#66d9ef">optional</span> <span style="color:#66d9ef">string</span> title <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		<span style="color:#66d9ef">repeated</span> <span style="color:#66d9ef">string</span> snippets <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	}<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">repeated</span> Result result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p>如果你想要在它的父类型的外部使用重用这个消息，你将用<code>_Parent_._Type_</code>来指定:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">SomeOhterMessage</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">optional</span> SearchResponse.Result result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p>你可以使用任意深度的嵌套</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">Outer</span> {				<span style="color:#75715e">// Level 0
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">message</span> <span style="color:#a6e22e">MiddleAA</span> {	<span style="color:#75715e">// Level 1
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">message</span> <span style="color:#a6e22e">Inner</span> {		<span style="color:#75715e">// Level 2
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">required</span> <span style="color:#66d9ef">int64</span> ival <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>			<span style="color:#66d9ef">optional</span> <span style="color:#66d9ef">bool</span> booly <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		}<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	}<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">message</span> <span style="color:#a6e22e">MiddleBB</span> {	<span style="color:#75715e">// Level 1
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">message</span> <span style="color:#a6e22e">Inner</span> {		<span style="color:#75715e">// Level 2
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">required</span> <span style="color:#66d9ef">int32</span> ival <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>			<span style="color:#66d9ef">optional</span> <span style="color:#66d9ef">bool</span> booly <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		}<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	}<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><h4 id="分组">分组</h4>
<blockquote>
<p><strong>注意：此功能不推荐使用，在创建新消息类型的时候不应该使用，应该使用嵌套的消息类型。</strong></p>
<p>分组类型是另一种获得嵌套信息的方式。比如，为<code>SearchResponse</code>指定一个包含一系列<code>SearchResponse</code>的消息将会如下所示：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">SearchResponse</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">repeated</span> <span style="color:#66d9ef">group</span> Result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		<span style="color:#66d9ef">required</span> <span style="color:#66d9ef">string</span> url <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		<span style="color:#66d9ef">optional</span> <span style="color:#66d9ef">string</span> title <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		<span style="color:#66d9ef">repeated</span> <span style="color:#66d9ef">string</span> snippets <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	}<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p>组只是将嵌套的消息类型和字段组合到了一个声明中。在您的代码中，您可以将此消息视为具有<code>Result</code>类型字段名叫<code>result</code>（后一个result变为小写，以防与前一个名称冲突）。因此，这个示例与上面的<code>SearchResponse</code>完全相同，只是消息具有不同的有线格式。</p>
</blockquote>
<h3 id="span-idupdating更新消息类型updating-a-message-typespan"><span id="updating">更新消息类型(Updating a message type)</span></h3>
<blockquote>
<p>如果一个已有的消息类型将不再满足你的需要，比如：你可能想要你的消息格式中含有一个额外的字段，但是你仍然想使用老格式生成的代码，不必担心！在不用破坏已有代码的基础上可以非常容易的做到这一点，只需要遵循以下的规则：</p>
<ul>
<li>不去改变已有的字段的数字标识符。</li>
<li>新加入的字段都由<code>optional</code>或者<code>repeated</code>修饰。这意味着使用“旧”消息格式的代码序列化的任何消息都可以由新生成的代码解析 ，因为他们不会丢失任何<code>required</code>修饰的元素。您应该将这些元素设置成合理的默认值，以便新的代码能够正确地与旧的代码生成的消息交互。类似地，新代码创建的消息可以由旧代码解析：旧二进制文件在解析时简单地忽略新代码的字段。但是，未知字段不会被丢弃，如果消息稍后被序列化，未知字段也会随之一起序列化，因此，如果消息传递到了新代码，新字段仍然是 可用的。</li>
<li>非<code>required</code>字段可以被移除，只要数字标识符不会再被你的新消息类型使用即可。你可能想要重新命名这些字段，也许加上“OBSOLETE_”前缀，或者是将字段的 标识符设置为保留状态，这样将来的用户不会意外的在你的<code>.proto</code>文件中重新使用这些字段。</li>
<li>非必须字段可以转换为扩展字段，反之亦然，只要保持类型和编号不变。</li>
<li><code>int32</code>,<code>uint32</code>,<code>int64</code>,<code>uint64</code>和<code>bool</code>值是兼容的—这意味着你可以将任意的将这些类型转换成其他的这些类型，而不会破坏他们的向前和向后的兼容性。如果从线路中解析出一个不适合对应类型的数字，您将得到与在C++中强制转换该数字相同的结果（例如，如果一个64位的数字被读取为<code>int32</code>，它将被截断为32位。</li>
<li><code>sint32</code>和<code>sint64</code>是兼容的，但是与其他整型是不兼容的。</li>
<li>只要保证字节为有效的UTF-8编码，那么<code>string</code>和<code>bytes</code>将是兼容的。</li>
<li>如果字节包含消息的编码版本，那么嵌入式消息将会与<code>bytes</code>兼容。</li>
<li><code>fixed32</code>与<code>sfixed32</code>兼容，<code>fixed64</code>与<code>sfixed64</code>兼容。</li>
<li>对于<code>string</code>,<code>bytes</code>和消息字段，<code>optional</code>和<code>repeated</code>是兼容的。可以给定<code>repeated</code>字段的序列化数据作为输入，如果该字段是原始类型的字段，则期望该字段是<code>optional</code>的客户机将把最后一个输入的值作为数值，若是一个消息类型的字段则会把所有的输入元素合并。注意，对于数值类型，包括布尔和枚举类型，这通常是不安全的。数值类型的重复字段可以以打包的形式序列化，当客户端需要<code>opional</code>字段时，将无法正确解析这些字段。</li>
<li>改变一个默认值通常来讲是可行的，只要你记得默认值不会通过网络传送。因此，如果程序收到没有设置特定字段的消息，则程序将看到在该程序版本的协议中定义的默认值。它不会看到在发送方代码中定义的默认值。</li>
<li>就总线格式而言，枚举类型和<code>int32</code>,<code>uint32</code>,<code>int64</code>和<code>uint64</code>是兼容的（注意，如果值不合适的话，他们将会被截断），但是要注意的，当消息被反序列化的时候，客户急的代码可能会以不同的方式对待他们。值得注意的是，当反序列化消息时，未识别的枚举值将被丢弃，这使得字段的<code>has..</code>访问器返回false，并且其getter方法返回<code>enum</code>中的第一个值，或者如果制定了一个默认值则会返回默认值。在<code>repeated</code>枚举字段的情况下，任何无法识别的值都将从列表中删除。但是，整数字段将始终保留其值。因此，在有可能接受超出范围的枚举值时，对整数升级为<code>enum</code>这一操作要十分的小心。</li>
<li>当下的C++和Java实现中，当一个未识别的<code>enum</code>值被删除时，它们与其他未知字段一起存储。请注意，如果此数据被序列化，然后由识别这些值的客户端重新解析，则会 导致奇怪的行为。在<code>optional</code>可选字段的情况下，即使在反序列化原始message之后写入新值，旧值仍然可以被客户端识别。在<code>repeated</code>字段的情况下，旧值将出现在任何已识别和新添加的值之后，这意味着顺序将不被保留。</li>
<li>若将单个<code>optional</code>值转换为一个新的<code>oneof</code>值类型，这样做是安全的，并且与二进制兼容。若是将多个<code>optional</code>字段转换成一个新的<code>oneof</code>类型，若你能够确保没有代码一次设置了多个字段，这样做是安全的。将任意字段转换成一个已存在的<code>oneof</code>字段是不安全的。</li>
<li>在map&lt;K, V&gt;和相应的<code>repeated</code>字段之间更改字段是二进制兼容的（请参阅下面的map，来了解消息的布局和其他限制）。然而，更改的安全性依赖于应用程序：当反序列化和重序列化消息时，使用<code>repeated</code>字段定义的客户端将产生语义相同的结果，但是，使用map字段定义的客户端可能会对条目重新排序，并删除具有重复键的条目。</li>
</ul>
</blockquote>
<h3 id="span-idextensions扩展extensionsspan"><span id="extensions">扩展(Extensions)</span></h3>
<blockquote>
<p>扩展可以让你在一个消息中声明一个范围的字段数值可用于第三方的扩展。扩展名是字段的占位符，其类型不是由原始的<code>.proto</code>文件定义的。这允许其他<code>.proto</code>文件通过用字段编号定义部分或所有字段的类型来添加到您的消息定义中。让我们来看一个例子：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">Foo</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#75715e">//..
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">extensions</span> <span style="color:#ae81ff">100</span> <span style="color:#66d9ef">to</span> <span style="color:#ae81ff">199</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p>这就是说<code>Foo</code>中的字段号是[100, 199]的范围是为扩展而保留的。其他用户现在可以在它们自己的<code>.proto</code>文件中 添加新的字段到<code>Foo</code>，该文件将导入您的<code>.proto</code>，在指定的范围内使用字段号，例如：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">extend</span> <span style="color:#a6e22e">Foo</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">optional</span> <span style="color:#66d9ef">int32</span> bar <span style="color:#f92672">=</span> <span style="color:#ae81ff">126</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p>这个新加的名叫<code>bar</code>的字段，字段号为126，将添加到<code>Foo</code>的原始定义中。</p>
<p>当用户对<code>Foo</code>消息进行编码时，有线传输格式与用户在<code>Foo</code>中定义的字段完全相同。但是，在应用程序中访问扩展字段的方式与访问常规字段的方式略有不同-生成的数据访问代码有专门的访问器来处理扩展字段。所以，举个例子，这里将是你如何在C++中设置bar的值：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">Foo foo;
foo.SetExtension(bar, <span style="color:#ae81ff">15</span>);
</code></pre></div><blockquote>
<p>类似地，<code>Foo</code>类型定义的模版访问器<code>HasExtension()</code>，<code>ClearExtension()</code>，<code>GetExtension()</code>，<code>MutableExtension()</code>，和<code>AddExtension()</code>。它们的语义都与正常字段生成的相应访问器相匹配。有关使用扩展的更多信息，请参见所选语言的代码参考。</p>
<p>注意：扩展可以是任何字段类型，包括消息类型，但不能是<code>oneof</code>类型或者是<code>map</code>类型。</p>
</blockquote>
<h4 id="嵌套扩展">嵌套扩展</h4>
<blockquote>
<p>你可以在另一种类型中声明扩展：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">Baz</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">extend</span> <span style="color:#a6e22e">Foo</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		<span style="color:#66d9ef">optional</span> <span style="color:#66d9ef">int32</span> bar <span style="color:#f92672">=</span> <span style="color:#ae81ff">126</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	}<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#f92672">.</span><span style="color:#f92672">.</span><span style="color:#f92672">.</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p>在这种情况下，C++代码将会是这样：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">Foo foo;
foo.SetExtension(Baz<span style="color:#f92672">:</span><span style="color:#f92672">:</span>bar, <span style="color:#ae81ff">15</span>)
</code></pre></div><blockquote>
<p>换句话说，唯一的影响就是<code>bar</code>是在<code>Baz</code>的范围内定义的。</p>
<p>这是一个非常常见的引起混乱的地方：生命嵌套在消息类型中的扩展块并不意味着外部类型和扩展类型之间有任何关系。具体来说，上面的例子并不意味着<code>Baz</code>是<code>Foo</code>的任何子类。它的意思是符号栏是在<code>Baz</code>的范围内声明的，它只是个静态成员。</p>
<p>一个常见的模式是在扩展字段类型的范围内定义和扩展，例如某这里是一个<code>Foo</code>的扩展<code>Baz</code>类型，其中扩展被定义为<code>Baz</code>的一部分：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">Baz</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	exten Foo {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		<span style="color:#66d9ef">optional</span> Baz foo_ext <span style="color:#f92672">=</span> <span style="color:#ae81ff">127</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	}<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#f92672">.</span><span style="color:#f92672">.</span><span style="color:#f92672">.</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p>但是，不要求在该类型中定义具有消息类型的扩展，你也可以这样做：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">Baz</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#f92672">.</span><span style="color:#f92672">.</span><span style="color:#f92672">.</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e">// 这也可以放在一个不同的文件中
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extend</span> <span style="color:#a6e22e">Foo</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">optional</span> Baz foo_baz_ext <span style="color:#f92672">=</span> <span style="color:#ae81ff">127</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p>事实上，为了避免混淆，最好使用这种语法。如上所述，嵌套语法经常被不熟悉扩展的用户认为是子类化。</p>
</blockquote>
<h4 id="选择一个扩展数值">选择一个扩展数值</h4>
<blockquote>
<p>两个用户不对同一个消息使用同一个字段数值扩展是十分必要的。如果扩展被一位的解释为错误的类型，可能会导致数据的破坏。您可能还要考虑为项目自定义扩展变好的约定，以防止发生这种情况。</p>
<p>如果您的字段编号约定可能涉及扩展具有非常大的字段编号，您可以指定您的扩展范围，以最大可能的字段编号使用max关键字：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">Foo</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	extentions <span style="color:#ae81ff">1000</span> <span style="color:#66d9ef">to</span> <span style="color:#66d9ef">max</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><blockquote>
<p><code>max</code>是$2^{29}-1$，或者说536,870,911。</p>
<p>在选择字段号时，您的编号约定也需要避免字段号19000到19999（从<code>FieldDescriptor::kFirstReservedNumber</code>到<code>FieldDescriptor::kLastReservedNumber</code>），因为它们时Protocal Buffer的保留编号。可以定义包含此范围的扩展，但协议的编译器将不会允许使用这些数字定义实际的扩展。</p>
</blockquote>
<h3 id="span-idoneofoneofspan"><span id="oneof">Oneof</span></h3>
<blockquote>
<p>如果你在一个消息体中有多个<code>optional</code>字段并且同一时间最多只会有一个字段会有值，那么你通过<code>oneof</code>类型对这种行为加强并节省内存。</p>
<p><code>oneof</code>类型和可选字段的类型非常相像，但它是多个字段共享一块内存，并且这些字段在同一时间只能有一个有值，将一个字段设置值的同时，也清空了其他的所有字段。根据你选择的语言，你可以使用<code>case()</code>或者<code>WhichOneof()</code>方法来检查<code>oneof</code>中的哪个值被设置了（如果有的话）。</p>
</blockquote>
<h4 id="oneof的使用">Oneof的使用</h4>
<blockquote>
<p>为了在你的<code>.proto</code>文件中定义<code>oneof</code>类型，你需要使用<code>oneof</code>关键字和名称来定义，如下：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-protobuf" data-lang="protobuf"><span style="color:#66d9ef">message</span> <span style="color:#a6e22e">SampleMessage</span> {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	<span style="color:#66d9ef">oneof</span> test_oneof {<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		<span style="color:#66d9ef">string</span> name <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>		SubMessage sub_message <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>;<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>	}<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>}<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><h3 id="span-idmapsmapsspan"><span id="maps">Maps</span></h3>
<h3 id="span-idpackages包packagesspan"><span id="packages">包(Packages)</span></h3>
<h3 id="span-idservices定义服务defining-servicesspan"><span id="services">定义服务(Defining Services)</span></h3>
<h3 id="span-idoptions选项optionsspan"><span id="options">选项(Options)</span></h3>
<h3 id="span-idgenerating生成类generating-your-classesspan"><span id="generating">生成类(Generating Your Classes)</span></h3>

    </div>
</div><div id="social-media-share" class="has-text-centered">
	<p><i>Sharing is caring!</i></p>
	<br>
	
	<div class="share-buttons">
	    <a  href="https://www.facebook.com/sharer/sharer.php?u=%2fpost%2fprotobuf2languageguide%2f"
	        onclick="socialMediaPopUp(this.href, '', 500, 500); return false;"
	        title="Share on Facebook. Opens in a new window.">
	        <img src=/img/icons/45px/facebook.png>
	    </a>

	    <a  href="https://twitter.com/intent/tweet?text=Protobuf2%e8%af%ad%e8%a8%80%e6%8c%87%e5%8d%97%ef%bc%88%e7%bf%bb%e8%af%91%ef%bc%89&url=%2fpost%2fprotobuf2languageguide%2f"
	        onclick="socialMediaPopUp(this.href, '', 500, 500); return false;"
	        title="Share on Twitter. Opens in a new window." >
	        <img src=/img/icons/45px/twitter.png>
	    </a>

		<a  href="http://www.reddit.com/submit?url=%2fpost%2fprotobuf2languageguide%2f"
	        onclick="socialMediaPopUp(this.href, '', 900, 500); return false;"
	        title="Share on Reddit. Opens in a new window." >
	        <img src=/img/icons/45px/reddit.png>
	    </a>

	    <a  href="http://pinterest.com/pin/create/button/?url=%2fpost%2fprotobuf2languageguide%2f"
	        onclick="socialMediaPopUp(this.href, '', 900, 500); return false;"
	        title="Share on Pinterest. Opens in a new window." >
	        <img src=/img/icons/45px/pinterest.png>
	    </a>

	    <a  href="http://www.tumblr.com/share/link?url=%2fpost%2fprotobuf2languageguide%2f"
	        onclick="socialMediaPopUp(this.href, '', 900, 500); return false;"
	        title="Share on Tumblr. Opens in a new window." >
	        <img src=/img/icons/45px/tumblr.png>
	    </a>

		<a  href="https://www.linkedin.com/shareArticle?mini=true&url=%2fpost%2fprotobuf2languageguide%2f
			&title=Protobuf2%e8%af%ad%e8%a8%80%e6%8c%87%e5%8d%97%ef%bc%88%e7%bf%bb%e8%af%91%ef%bc%89&summary=%e6%b3%a8%ef%bc%9a%e5%86%85%e5%ae%b9%e7%bf%bb%e8%af%91%e8%87%aa%e5%ae%98%e6%96%b9%e6%96%87%e6%a1%a3%ef%bc%8c%e4%bb%85%e4%bd%9c%e4%b8%aa%e4%ba%ba%e5%ad%a6%e4%b9%a0%e4%bd%bf%e7%94%a8%e3%80%82%e5%8e%9f%e6%96%87%0a%20%e8%af%ad%e8%a8%80%e6%8c%87%e5%8d%97%20%20%20%e5%ae%9a%e4%b9%89%e4%b8%80%e4%b8%aa%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b%0a%20%20Scalar%e5%80%bc%e7%b1%bb%e5%9e%8b%0a%20%20%e5%8f%af%e9%80%89%e5%80%bc%e4%b8%8e%e9%bb%98%e8%ae%a4%e5%80%bc%0a%20%20%e6%9e%9a%e4%b8%be%0a%20%20%e4%bd%bf%e7%94%a8%e5%85%b6%e4%bb%96%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b%0a%20%20%e5%b5%8c%e5%a5%97%e7%b1%bb%e5%9e%8b%0a%20%20%e6%9b%b4%e6%96%b0%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b%0a%20%20%e6%89%a9%e5%b1%95%0a%20%20Oneof%0a%20%20Maps%0a%20%20%e5%8c%85%0a%20%20%e5%ae%9a%e4%b9%89%e6%9c%8d%e5%8a%a1%0a%20%20%e9%80%89%e9%a1%b9%0a%20%20%e7%94%9f%e6%88%90%e7%b1%bb%0a%20%e8%bf%99%e4%b8%aa%e6%8c%87%e5%8d%97%e4%b8%ba%e6%88%91%e4%bb%ac%e6%8f%8f%e8%bf%b0%e4%ba%86%e5%88%a9%e7%94%a8Protocal%20Buffer%e8%af%ad%e8%a8%80%e6%9d%a5%e7%bb%93%e6%9e%84%e5%8c%96Protocal%20Buffer%e6%95%b0%e6%8d%ae%e7%9a%84%e6%96%b9%e6%b3%95%ef%bc%8c%e5%8c%85%e6%8b%ac%e4%ba%86.proto%e6%96%87%e4%bb%b6%e7%9a%84%e8%af%ad%e6%b3%95%e5%92%8c%e6%80%8e%e6%a0%b7%e4%bb%8e.proto%e6%96%87%e4%bb%b6%e4%b8%ad%e7%94%9f%e6%88%90%e6%95%b0%e6%8d%ae%e8%ae%bf%e9%97%ae%e7%b1%bb%e3%80%82%e5%85%b6%e5%8c%85%e5%90%ab%e4%ba%86proto2%e7%89%88%e6%9c%ac%e7%9a%84%e5%86%85%e5%ae%b9%ef%bc%9a%e5%a6%82%e6%9e%9c%e6%83%b3%e4%ba%86%e8%a7%a3%e6%9c%89%e5%85%b3%e4%b8%8eproto3%e7%9a%84%e8%af%ad%e6%b3%95%ef%bc%8c%e8%af%b7%e5%8f%82%e7%9c%8bProto3%20Language%20Guide%e3%80%82%0a%20%20%20%e5%ae%9a%e4%b9%89%e4%b8%80%e4%b8%aa%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b%28Defining%20a%20message%20type%29%20%20%e9%a6%96%e5%85%88%ef%bc%8c%e8%ae%a9%e6%88%91%e4%bb%ac%e6%9d%a5%e7%9c%8b%e4%b8%80%e4%b8%aa%e9%9d%9e%e5%b8%b8%e7%ae%80%e5%8d%95%e7%9a%84%e4%be%8b%e5%ad%90%e3%80%82%e6%88%91%e4%bb%ac%e8%af%b4%e5%bd%93%e4%bd%a0%e6%83%b3%e8%a6%81%e5%ae%9a%e4%b9%89%e4%b8%80%e4%b8%aaSearch%20Request%e7%9a%84%e6%b6%88%e6%81%af%e6%a0%bc%e5%bc%8f%ef%bc%8c%e5%85%b6%e4%b8%ad%e6%af%8f%e4%b8%80%e4%b8%aaSearch%20Request%e9%83%bd%e6%9c%89%e4%b8%80%e4%b8%aa%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%b1%bb%e5%9e%8b%e7%9a%84Query%ef%bc%8c%e4%b8%80%e4%b8%aa%e4%bd%a0%e6%84%9f%e5%85%b4%e8%b6%a3%e5%86%85%e5%ae%b9%e7%9a%84%e7%89%b9%e5%ae%9a%e9%a1%b5%e7%a0%81%ef%bc%8c%e8%bf%98%e6%9c%89%e6%af%8f%e4%b8%80%e9%a1%b5%e9%9c%80%e8%a6%81%e5%a4%9a%e5%b0%91%e7%bb%93%e6%9e%9c%e3%80%82%e4%b8%8b%e9%9d%a2%e7%9a%84.proto%e6%96%87%e4%bb%b6%e5%b0%b1%e6%98%af%e6%9d%a5%e5%ae%9a%e4%b9%89%e4%b8%8a%e8%bf%b0%e7%9a%84%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b%e3%80%82%0a%20message%20SearchRequest%20%7b%09required%20string%20query%20%3d%201%3b%09optional%20int32%20page_number%20%3d%202%3b%09optional%20int32%20result_per_page%20%3d%203%3b%7d%20%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b%e7%9a%84SearchRequest%e4%b8%ad%e5%ae%9a%e4%b9%89%e4%ba%86%e4%b8%8a%e8%bf%b0%e6%89%80%e8%a6%81%e6%b1%82%e7%9a%84%e4%b8%89%e4%b8%aa%e5%ad%97%e6%ae%b5%ef%bc%88%e5%90%8d%e7%a7%b0%2f%e5%80%bc%20%e7%9a%84%e5%af%b9%ef%bc%89%ef%bc%8c%e6%af%8f%e4%b8%80%e4%bb%bd%e6%95%b0%e6%8d%ae%e9%83%bd%e4%bc%9a%e5%9c%a8%e5%ad%97%e6%ae%b5%e4%b8%ad%e6%9c%89%e7%9b%b8%e5%ba%94%e7%9a%84%e6%95%b0%e6%8d%ae%ef%bc%8c%e6%af%8f%e4%b8%80%e4%b8%aa%e5%ad%97%e6%ae%b5%e9%83%bd%e6%9c%89%e4%b8%80%e4%b8%aa%e5%90%8d%e7%a7%b0%e5%92%8c%e4%b8%80%e4%b8%aa%e7%b1%bb%e5%9e%8b%e3%80%82&source=rafed123.github.io"
	        onclick="socialMediaPopUp(this.href, '', 900, 500); return false;"
	        title="Share on LinkedIn. Opens in a new window." >
	        <img src=/img/icons/45px/linkedin.png>
	    </a>

	    <a  href="mailto:?subject=Protobuf2%e8%af%ad%e8%a8%80%e6%8c%87%e5%8d%97%ef%bc%88%e7%bf%bb%e8%af%91%ef%bc%89&amp;body=Check out this site %2fpost%2fprotobuf2languageguide%2f"
	        title="Share via Email. Opens in a new window." >
	        <img src=/img/icons/45px/mail.png>
	    </a>
	</div>
</div>


<br>
<div id="disqus_thread"></div>
<script type="text/javascript">
    (function () {
        
        
        if (window.location.hostname == "localhost")
            return;

        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = '';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


        </div>
    </div>

<footer class="footer has-background-dark">
    <div class="content has-text-centered has-text-white">
        <p>
            © 2020 Ramium. Powered by
            <a class="has-text-light" href="https://github.com/gohugoio/hugo" target="_blank">
            Hugo</a>. Theme
            <a class="has-text-light" href="https://github.com/rafed123/ramium/" target="_blank">
                Ramium.
            </a>
        </p>
    </div>
</footer>
</body>

</html>